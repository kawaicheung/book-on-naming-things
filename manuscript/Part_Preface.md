# Preface

I don’t like calling what I do programming. It sounds like I spend my days plugging in some series of commands from an instruction manual to get something to work -- like I would if I were setting up the air conditioning schedule in my apartment. Coding is only marginally better. But, the name only details part of my job -- creating some technical instruction that a compiler can interpret into machine code.

Writing code? OK, that’s closer. I don’t code solely for the machine, I write code so that other code writers also understand what I’m telling the compiler to do. Humans need much more quality time with written code to get to that understanding than a compiler does. Still, it’s missing something. 

I’ve landed on this: I write software. Just like someone else might write a book or play, I write software. I wouldn’t say Hemingway wrote English -- he wrote novels. In the same way, I don’t write code, I write software.

Writing software is a long leap from programming. It means that I care about what other “normal” writers care about -- style, clarity, tone, and telling a good story. There is a whole lot of qualitative judgment when it comes to well-written software.

But, this is kind of a foreign idea. Our industry champions metrics like line counts, Big(O) complexity, and test coverage -- things we can quantify. But, it’s hard to measure code aesthetics.  How can we definitively say one software writer’s approach is more well-written than anothers’? 

Judging good software writing is heavily subjective. So, I decided, as any pragmatic software writer might, to tackle just a sliver of that subject: Naming things. There are clearly good names, and there are clearly bad names, and there is a whole lot of gray area in between. This book tries to differentiate between the two and offer some strong opinions for the vast middle.

You might very well disagree with my opinions. But, having the debate is worthwhile in and of itself. Getting us software writers to think critically about the names we give things is a big step to better, more enjoyable software reading.